//! Trait for output forms (forms generated by the calculator).

use crate::money::Money;
use crate::types::{OutputFormType, TaxYear};
use serde::{Deserialize, Serialize};

/// A value that can appear on a tax form line.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type", content = "value")]
pub enum FormValue {
    /// Currency amount (most common).
    Currency(Money),
    /// Integer value (e.g., number of dependents).
    Integer(i64),
    /// Text value (e.g., names, addresses).
    Text(String),
    /// Boolean/checkbox value.
    Boolean(bool),
    /// Line does not apply for this tax year or situation.
    NotApplicable,
}

impl FormValue {
    /// Returns the value as Money, if it is a currency value.
    pub fn as_money(&self) -> Option<Money> {
        match self {
            FormValue::Currency(m) => Some(*m),
            _ => None,
        }
    }

    /// Returns the value as i64, if it is an integer value.
    pub fn as_integer(&self) -> Option<i64> {
        match self {
            FormValue::Integer(i) => Some(*i),
            _ => None,
        }
    }

    /// Returns the value as &str, if it is a text value.
    pub fn as_text(&self) -> Option<&str> {
        match self {
            FormValue::Text(s) => Some(s),
            _ => None,
        }
    }

    /// Returns the value as bool, if it is a boolean value.
    pub fn as_bool(&self) -> Option<bool> {
        match self {
            FormValue::Boolean(b) => Some(*b),
            _ => None,
        }
    }

    /// Returns true if this line is not applicable.
    pub fn is_not_applicable(&self) -> bool {
        matches!(self, FormValue::NotApplicable)
    }
}

impl From<Money> for FormValue {
    fn from(m: Money) -> Self {
        FormValue::Currency(m)
    }
}

impl From<i64> for FormValue {
    fn from(i: i64) -> Self {
        FormValue::Integer(i)
    }
}

impl From<String> for FormValue {
    fn from(s: String) -> Self {
        FormValue::Text(s)
    }
}

impl From<&str> for FormValue {
    fn from(s: &str) -> Self {
        FormValue::Text(s.to_string())
    }
}

impl From<bool> for FormValue {
    fn from(b: bool) -> Self {
        FormValue::Boolean(b)
    }
}

/// A single line on an output form.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FormLine {
    /// Line identifier (e.g., "1a", "12", "15").
    pub line_id: String,
    /// Human-readable label.
    pub label: String,
    /// The value for this line.
    pub value: FormValue,
}

/// Trait implemented by all output forms (1040, schedules, etc.).
///
/// Output forms represent the tax forms generated by the calculator.
/// They provide a version-aware interface to access form line values.
///
/// # Example
///
/// ```ignore
/// use honest_tax_core::traits::OutputForm;
///
/// let form_1040 = calculate_taxes(&inputs)?;
/// let taxable_income = form_1040.line("15").and_then(|v| v.as_money());
/// ```
pub trait OutputForm: Send + Sync + std::fmt::Debug {
    /// Returns the form type identifier.
    fn form_type(&self) -> OutputFormType;

    /// Returns the tax year this form is for.
    fn tax_year(&self) -> TaxYear;

    /// Returns the value for a specific line.
    ///
    /// Line IDs are version-aware: the same semantic value may have
    /// different line numbers across tax years.
    fn line(&self, line_id: &str) -> Option<FormValue>;

    /// Returns all populated lines on this form.
    fn lines(&self) -> Vec<FormLine>;

    /// Serialize the form to JSON.
    fn to_json(&self) -> serde_json::Value {
        serde_json::json!({
            "form_type": format!("{}", self.form_type()),
            "tax_year": self.tax_year(),
            "lines": self.lines()
        })
    }
}

/// Metadata about a form line across tax years.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FormLineSpec {
    /// Canonical line identifier.
    pub line_id: String,
    /// Human-readable label.
    pub label: String,
    /// First tax year this line appeared.
    pub introduced_year: TaxYear,
    /// Tax year this line was removed (if ever).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub removed_year: Option<TaxYear>,
    /// Previous line ID if this line was renumbered.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub renamed_from: Option<String>,
    /// Description of what this line represents.
    pub description: String,
    /// Expected value type.
    pub value_type: FormValueType,
}

/// The expected type of value for a form line.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FormValueType {
    Currency,
    Integer,
    Text,
    Boolean,
}

impl FormLineSpec {
    /// Returns true if this line is valid for the given tax year.
    pub fn is_valid_for_year(&self, year: TaxYear) -> bool {
        year >= self.introduced_year
            && self.removed_year.map_or(true, |removed| year < removed)
    }
}

/// Schema definition for an entire form.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FormSchema {
    /// Form type identifier.
    pub form_type: String,
    /// Human-readable form name.
    pub form_name: String,
    /// IRS form number.
    pub irs_form_number: String,
    /// Minimum supported tax year.
    pub min_year: TaxYear,
    /// Maximum supported tax year (if known).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_year: Option<TaxYear>,
    /// Line specifications.
    pub lines: Vec<FormLineSpec>,
}

impl FormSchema {
    /// Returns line specs valid for the given tax year.
    pub fn lines_for_year(&self, year: TaxYear) -> Vec<&FormLineSpec> {
        self.lines
            .iter()
            .filter(|line| line.is_valid_for_year(year))
            .collect()
    }

    /// Looks up a line spec by ID for the given tax year.
    pub fn get_line(&self, line_id: &str, year: TaxYear) -> Option<&FormLineSpec> {
        self.lines
            .iter()
            .find(|line| line.line_id == line_id && line.is_valid_for_year(year))
    }
}
